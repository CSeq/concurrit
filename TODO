- end of script olan branchlara, endscriptnode : endnode ve bir backtrack(endofscript) exception
- AcquireRef'deki timer'in zamanini parametre yap
--- end node'u ekleyince ortadan onceki child'lara ne olacak?
- eger script bittigi icin backtrack yapan kod varsa, backtrack sirasinda bunu tespit edip covered yap
--- ayni nodelari tespit etmek icin source location kullan.
- son transition'i controllable yap ends() burada true yapilacak, nasil???
- pin icin variable ve functionlari basta belirle, sadece bunlarin instrumente edilmesini sagla
- script bittikten sonra controlled transition devam ediyorsa backtrack et, success olmasin.
---- satisfy edilmeyen transitionlar nedeniyle olan backtrackli executionlari forall'da sayma
- hem read, hem de write yapan instructionlarda ne yapacagiz?
- INSTANCEOF lari ASINSTANCEOF ile yer degistir dynamic castlari bire dusurmek icin

 -- pin instrumentation'i kaldir!!!
- rununcontrolled yield mod icin nasil calisacak, ayri flag gerekebilir!

- if(ENABLED <= status && status < BLOCKED) {
- group.restart ederken blocklayan threadleri kill et.
- kill edilen threadlerin yeniden calisabilmesini sagla
- PASSIVE ya da TERMINATED'dan bir status'u sil coroutine'den (once gerekli mi diye bak)
- void Coroutine::Start(bool conc /*= false*/) { : ExecutionMode yeterli mi yoksa parametreye gerek var mi?


FEATURES
		threadleri yield noktasina kadar parallel calistir.
		timer tut, tek tek ve toplam zamani olc, sonunda raporla. Kuda'dan zamanla ilgili kodlari al.
		vctracker'li ve coverage'li scenario'yu default scenario'dan ayir.

		dpor'u compile time flag degil runtime flag yap.
		cogu zaman bir execution birden fazla ziyaret ediliyor, yielddan sonra transferde ayni yere gitmemesi icin bir flag koy
		sadece bir thread varsa o threadden yield yapma sonuna kadar. bunun icin de flag koy cunku bazen gerekli olabiliyor.
		yield yaptiktan sonra baska bir thread'i sec. bunun icin de bir flag koy ya da EXCEPT ile devam et.
		yieldpointdeki prev pointeri kullanarak last coming coroutine;i belirle ve bunu kullanarak EXCEPT_LAST() ekle.
		yieldpoint'de next pointera gerek var mi?
		
		save etme ve replay etme
		UNTIL(TRANSFER) seklinde olsun -- lambda expressions -- http://matt.might.net/articles/static-closures-in-c-plus-plus/
		generate test scenarios from schedules
		sequential mode yaninda true concurrency modu koy, direk threadleri senkronize etmeden calistir.
		
		handle case where a yield point is associated with not only a single access but a set of accesses
		lp.cpp'deki TODO'lara bak, onlarla ilgilen.
		
REFACTORINGS
		std::string yerine olabildigince const char* kullan
		