- script bittikten sonra controlled transition devam ediyorsa backtrack et, success olmasin.
- sem_ref_'i kontrol et!!!
- hem read, hem de write yapan instructionlarda ne yapacagiz?
- satisfy edilmeyen transitionlar nedeniyle olan backtrackli executionlari forall'da sayma
- beforecontrolled transition'dan sonra timer koy, after transition olana kadar timer expire olursa handle et.
- bir transition'i hic bir thread satisfy etmezse ne olacak? backtrack yapmamiz gerekiyor!!!
- node eklerken threadlerin alive olup olmadigina da bak!!! olurlerse node'lari acquire edemezler, su anda bu yapiliyor ama daha efficient nasil yapilabilir? 
- true ve false transition predicateleri static global variable yap, tek instance olsunlar.
- INSTANCEOF lari ASINSTANCEOF ile yer degistir dynamic castlari bire dusurmek icin

 -- pin instrumentation'i kaldir!!!
- rununcontrolled yield mod icin nasil calisacak, ayri flag gerekebilir!

- if(ENABLED <= status && status < BLOCKED) {
- group.restart ederken blocklayan threadleri kill et.
- kill edilen threadlerin yeniden calisabilmesini sagla
- PASSIVE ya da TERMINATED'dan bir status'u sil coroutine'den (once gerekli mi diye bak)
- void Coroutine::Start(bool conc /*= false*/) { : ExecutionMode yeterli mi yoksa parametreye gerek var mi?


FEATURES
		threadleri yield noktasina kadar parallel calistir.
		timer tut, tek tek ve toplam zamani olc, sonunda raporla. Kuda'dan zamanla ilgili kodlari al.
		vctracker'li ve coverage'li scenario'yu default scenario'dan ayir.

		dpor'u compile time flag degil runtime flag yap.
		cogu zaman bir execution birden fazla ziyaret ediliyor, yielddan sonra transferde ayni yere gitmemesi icin bir flag koy
		sadece bir thread varsa o threadden yield yapma sonuna kadar. bunun icin de flag koy cunku bazen gerekli olabiliyor.
		yield yaptiktan sonra baska bir thread'i sec. bunun icin de bir flag koy ya da EXCEPT ile devam et.
		yieldpointdeki prev pointeri kullanarak last coming coroutine;i belirle ve bunu kullanarak EXCEPT_LAST() ekle.
		yieldpoint'de next pointera gerek var mi?
		
		save etme ve replay etme
		UNTIL(TRANSFER) seklinde olsun -- lambda expressions -- http://matt.might.net/articles/static-closures-in-c-plus-plus/
		generate test scenarios from schedules
		sequential mode yaninda true concurrency modu koy, direk threadleri senkronize etmeden calistir.
		
		handle case where a yield point is associated with not only a single access but a set of accesses
		lp.cpp'deki TODO'lara bak, onlarla ilgilen.
		
REFACTORINGS
		std::string yerine olabildigince const char* kullan
		